package owl.embed.contactmaps;

import java.io.*;
import java.sql.SQLException;
import java.util.*;

import owl.core.structure.Pdb;
import owl.core.structure.PdbCodeNotFoundException;
import owl.core.structure.PdbLoadError;
import owl.core.structure.PdbasePdb;
import owl.core.util.MySQLConnection;
import owl.core.util.RegexFileFilter;


import edu.uci.ics.jung.graph.util.Pair;


/**
 * This class is an interface class, that converts all contact map files with extensions '.cmap', '.indi' or '.ust' to one PyMol log files (with extension '.pml').
 * This '.pml' file contains all important PyMol commands to generate a set of frames, where each set corresponds to one generation at a given state (the
 * generation number) and the set is displayed as a protein structure rotating 360 degrees. The resulting '.pml' file is executable from command line in
 * either PyMol or directly from command line 'pymol directory+file name'.
 * <p>
 * </p>
 * <p>
 * The format of these '.cmap', '.indi' or '.ust' files should be conform with those generated by the <code>{@link printToFile(String, String)}</code> method 
 * in the <code>{@link #Species}</code> class. By generating an array of a class instances of this class, one can automatically handle larger sets of directories 
 * containing '.cmap', '.indi' or '.ust' files, which are usually generated by each run of the <code>main</code> method of the <code>{@link #Population}</code> class.
 * The only two implemented constructors are a one-parameter constructor, with a <code>{@link #String}</code> denoting the absolute path of a directory contain contact map files
 * and a two-parameter constructor with a String argument denoting the directory and an integer argument specifying the number of frames assigned to each generation in the movie
 * to be made. The directory has to contain at least one 'cmap', '.indi' or '.ust' file, or the run will be exited accompanied with an error message stating the reason of abrupt termination.
 * </p>
 * <p>
 * </p>
 * <p>
 * If the 'cmap', '.indi' or '.ust' files were not generated by a run of the <code>{@link #Population}</code> class, the following must be taken into consideration:
 * </p>
 * <p>
 * - firstly, the '.cmap', '.indi' or '.ust' file numbering must be consistent with the generation number, if the file name itself does not contain any information about
 * the generation.
 * </p>
 * <p>
 * - secondly, since all '.cmap' files within one directory are considered to belong to one so called deme, '.cmap' files belonging to different demes
 * must be placed in different directories prior any processing should be undertaken.
 * </p>
 *  
 */
public class CMGrabber {
	
	/*-----------------------------------------------constances--------------------------------------------------*/
	
	private static final String[] file_types = {".*.cmap",".*.indi",".*.ust"}; 
	
	/*---------------------------------------------member variables----------------------------------------------*/
	
	/**
	 * String denoting the file type contained in the directory denoted by <code>{@link #dirlist}</code>.
	 */
	private static String file_type;
	
	/**
	 * a <code>{@link #File}</code> instance, to avoid abrupt termination this should always be a directory, containing at least one '.cmap', '.indi' and '.ust' file.
	 */
	private File dirlist; 			//a File instance, which must be a directory containing '.cmap', '.indi' and '.ust' files.
	
	/**
	 * an array of <code>{@link #File}</code> instances, representing the '.cmap', '.indi' and '.ust' files. 
	 */
	private File[] filelist;		//a File array containing only '.cmap', '.indi' and '.ust' files.
	
	/**
	 * the number of frames assigned to one group
	 */
	private int[] frameindices;		//this int array contains the number of distance selections in each frame ensemble
	//which is used in turn to group all distance to generate 60 frames for each evolution step, in which the protein
	//model will be fully rotated,
	
	private int[] generation_indeces;//if the '.cmap', '.indi' and '.ust' file contains info of the generation number it will be saved in
	//this array, so the i-th file will only appear in the generation_indeces[i] frame range,
	
	private int frame_number;		//the number of frames to which each generation is assigned
	
	private String path;			//this field contains the absolute path of the directory containing all '.cmap', '.indi' and '.ust' files.
	
	private String name;			//the name of the the protein, i.e. the PDB code 
	
	private String grouping;		//a String instance containing all grouping commands
	
	private String pdb_dir;
	
	private String filecontent;		//file content: saves all PyMol commands needed to generate a mpeg movie file, where
	//each generation is displayed as fully rotating protein structure with the specific contacts shown as distance bars
	
	private HashMap<String,HashSet<String>> movieframekeeper;//a HashMap containing the generation numbering and the grouping
	//Strings, which belong to one set of movie frames
	
	/*------------------------------------------constructors---------------------------------------*/
	/**
	 * One-parameter constructor: initializes a <code>CMGrabber</code> instance as implemented in the <code>{@link #setCMGrabber(String)}</code>
	 * setter method.
	 * @param dir - a String denoting the directory to process
	 * @throws FileNotFoundException
	 * @throws IllegalArgumentException
	 * @throws IOException
	 */
	public CMGrabber (String dir) throws FileNotFoundException, IllegalArgumentException, IOException{
		setCMGrabber(dir,60);
	}
	
	/**
	 * Tow-parameter constructor: initializes a <code>CMGrabber</code> instance as implemented in the <code>{@link #setCMGrabber(String)}</code>
	 * setter method. This constructor additionally offers the possibility to specify the number of frames assigned to each 
	 * generation.
	 * @param dir - a String denoting the directory to process
	 * @param framenum - number of frames assigned to each generation
	 * @throws FileNotFoundException
	 * @throws IllegalArgumentException
	 * @throws IOException
	 */
	public CMGrabber (String dir, int framenum) throws FileNotFoundException, IllegalArgumentException, IOException{
		setCMGrabber(dir, framenum);
	}
	
	/**
	 * One-parameter constructor: initializes a <code>CMGrabber</code> instance as implemented in the <code>{@link #setCMGrabber(String)}</code>
	 * setter method.
	 * @param dir - a File instances representing the directory to process 
	 * @throws FileNotFoundException
	 * @throws IllegalArgumentException
	 * @throws IOException
	 */
	public CMGrabber (File dir) throws FileNotFoundException, IllegalArgumentException, IOException{
		String dirname = dir.getAbsolutePath();
		setCMGrabber(dirname,60);
	}
	
	/**
	 * Two-parameter constructor: initializes a <code>CMGrabber</code> instance as implemented in the <code>{@link #setCMGrabber(String)}</code>
	 * setter method. This constructor additionally offers the possibility to specify the number of frames assigned to each 
	 * generation.
	 * @param dir - a File instances representing the directory to process
	 * @param framenum - number of frames assigned to each generation
	 * @throws FileNotFoundException
	 * @throws IllegalArgumentException
	 * @throws IOException
	 */
	public CMGrabber (File dir, int framenum) throws FileNotFoundException, IllegalArgumentException, IOException{
		String dirname = dir.getAbsolutePath();
		setCMGrabber(dirname,framenum);
	}
	
	/*--------------------------------------------------void-------------------------------------------------*/
	/*------------------------------------------------setter-------------------------------------------------*/
	
	/**
	 * Setter: initializes all fields in this class. First, the directory denoted by the parameter <code>dir</code> is checked whether it
	 * contains any '.cmap' files. If it does contain this kind of files, they are listed in an array of <code>File</code> instances and sequentially
	 * read, according to the order with is specified by the <code>{@link #sort(Object[])}</code> in the <code>{@link #Arrays}</code> class (the order of their file name).
	 * @param dir - the <code>String</code> denoting the directory containing the files to be processed
	 * @throws FileNotFoundException directory does not exist
	 * @throws IllegalArgumentException either the directory does not contain any '.cmap' files or is not a directory
	 * @throws IOException 
	 */
	public void setCMGrabber (String dir, int frame_num) throws FileNotFoundException, IllegalArgumentException, IOException {
		path = new String (dir+"/");							//field 'path' initialized
		
		File dirtest = new File (dir);
		if(dirtest.exists()){									//check, whether the denoted File instance exists
			
			if(dirtest.isDirectory()){							//check, whether the denoted File instance is a directory
				
				if(containsCMapFiles(dirtest)){					//check, whether the directory contains any '.cmap', '.indi' or 'ust' files
					
					frame_number = frame_num;				//the number of frames assigned to each rotation
					
					dirlist = new File (dirtest.getAbsolutePath());		//if all check points passed, the field 'dirlist' is initialized
					
					filelist = dirlist.listFiles(new RegexFileFilter (file_type));		//the field 'filelist' is 
					//initialized using the listFiles(FileFilter) method, considering only those files, with the substring '.cmap'
					
					Arrays.sort(filelist);					//sorting the file list lexicographically
					
					int length = filelist.length;
					filecontent = ""; setGenerationIndeces(length);	//initializing the field 'filecontent' and 'generation_indeces'
					
					frameindices = new int[length];
					pdb_dir = path;
					for(int i = 0; i < length; i++){			//looping over the File array, to read the content of each '.cmap' file
						
						filecontent += readFiles(i,"dummy");			//reading the File by using the readFile(int,String) method
						
					}
					
				}
				else{
					throw new IllegalArgumentException ("The directory '"+dir+"' does not contain any '.cmap' file!");
					//if the File instance 'dirtest' does not contain any '.cmap' files
					
				}
			}
			else{
				throw new IllegalArgumentException("The path '"+dir+"' is not a directory!");
				//if the File instance 'dirtest' is not a directory
				
			}
		}
		else{
			throw new FileNotFoundException ("The directory '"+dir+"' does not exist!");
			//if the File instance 'dirtest' is not a directory
			
		}
	}
	
	/**
	 * auxiliary setter: sets the field <code>generation_indeces</code> to an int array with <code>length</code>
	 * entries, setting the default entry to <code>-1</code>. Each '.cmap' file in the field <code>filelist</code>
	 * containing the line
	 * <p>
	 * #GENERATION: number
	 * </p>
	 * <p>
	 * will change the entry to the 'number'. According to the numbering routine of the <code>{@link #Population}</code>
	 * the parental generation corresponds the 0-th generation and the first filial (daughter) generation corresponds to the
	 * first generation, and so on.
	 * </p> 
	 * @param length - number of entries, i.e. the number of contact map files
	 * @throws IllegalArgumentException if <code>length</code> is equal or less than zero
	 */
	public void setGenerationIndeces (int length) throws IllegalArgumentException {
		if(length > 0){
			generation_indeces = new int[length];
			for(int i = 0; i < length; i++){
				generation_indeces[i] = -1;
			}
		}
		else{
			throw new IllegalArgumentException ("The parameter 'length' must never be less than zero, but was set to 'length = " + length);
		}
	}
	
	/*-------------------------------------------auxiliaries-----------------------------------------------------*/
	
	/**
	 * Auxiliary method: prints the field <code>filecontent</code> to a '.pml' (PyMol log file) to
	 * the 'PML' sub-directory of directory denoted by the field <code>path</code>. This file can be
	 * executed from command line or directly in PyMol.
	 */
	public void printToFile () throws IOException, SQLException, PdbCodeNotFoundException, PdbLoadError{
		File test = new File (path + "PML/");
		if(!test.exists()){					//check, whether the denoted directory exists
			
			test.mkdirs();
		}
		if(name != null){				//check, if the field 'name' was initialized
			
			dumpToPDBFile();			//creating a PDB file in the directory denoted by the field 'path'
			
			FileOutputStream out = new FileOutputStream (path + "PML/" + name+".pml");
			PrintStream printa = new PrintStream (out);
			addTrailer();				//calling the auxiliary method, which is need to group all distances to their frames
			
			if(filecontent != null){	//check, if the field 'filecontent' was initialized
				
				printa.print(filecontent);
				
			}
			else{
				printa.close();
				out.close();
				throw new NullPointerException ("The field 'filecontent' was not initialized!");
			}
			printa.close();
			out.close();
			System.out.println("Contact Maps in "+path+" successfully written to file...");
		}
		else{
			throw new NullPointerException("The field 'name' was not initialized");
		}
	}
	
	/**
	 * Auxiliary method: when all distances belonging to one generation were generated, they must be grouped
	 * in order to easily access them, when assignment to each movie frame is needed. This is accomplished by
	 * adding each distance name (which is composed in the following manner: 'Sel + number + PDB code') to a
	 * <code>HashSet</code>, which in turn is added to a <code>HashMap</code>, the field <code>movieframekeeper</code>.
	 * The generation number is mapped to the <code>HashSet</code> of group strings. The helpstring <code>grouping</code>
	 * is added to the field <code>filecontent</code>.
	 */
	public void grouping (){
		HashMap<String,HashSet<String>> movieframes = getMovieFrameKeeper();		//getting the map of all distance selections
		//and their corresponding generation number
		
		Set<String> keyset = movieframes.keySet();
		Iterator<String> it1 = keyset.iterator();
		String groups = "";
		while(it1.hasNext()){												//iterating over the HashMap
			
			String frameindex = it1.next();
			HashSet<String> togroup = movieframes.get(frameindex);			//getting the HashSet containing all distance selection names
			
			Iterator<String> it2 = togroup.iterator();
			groups += "group " + frameindex + ",";								//initially, the PyMol command 'group' and the string representing the group,
			//followed by the distance selection names
			
			while(it2.hasNext()){											//iterating over the distance selection names
				
				groups += " " + it2.next();
			}
			groups += "\n";													//ending the line
			
		}
		grouping = new String (groups);								//initializing the field 'group'
	}
	
	/**
	 * Auxiliary method: after reading the file and initializing the field <code>filecontent</code>, a trailing string
	 * must be added. This string contains all distance selection names (grouped together by calling the <code>grouping()</code>
	 * method and the commands assigning each frame of a rotating protein to a set of distance selections.
	 */
	public void addTrailer (){
		int framenumber = frame_number;		//number of frames assigned to each generation/rotation
		
		grouping();							//calling the grouping method
		
		//String[] grouparray = getGrouping().split("\n");	//splitting the grouping string by their line terminators
		
		String helper = "";
		//int length = grouparray.length;
		Set<String> selector_set = getMovieFrameKeeper().keySet();
		Iterator<String> it = selector_set.iterator();
		while(it.hasNext()){									//iterating over all groups
			
			String selectorelement = it.next();			
			for(int j = 1; j < framenumber + 1; j++){			//iterating over all frames within one rotation
				
				int i = (int) Double.parseDouble(selectorelement.replaceAll("Sel","")) - 1;
				helper += "mdo " + (j + framenumber*i) + ": util.mroll(" + (j + framenumber * i) + "," + ((i + 1)*framenumber) + ",1); hide dashes; show dashes, " + selectorelement + "\n";
			}
		}
		int allframe_number = framenumber*filelist.length;	//number of all frames equals generations times number of frames per generation
		
		filecontent += getGrouping() +"mset 1 x"+allframe_number+"\nutil.mroll(1,"+allframe_number+",1)\n" + helper;
		//completing the field 'filecontent'
	}
	
	/**
	 * Auxiliary method: creates a PDB file by calling the <code>{@link #PDB.writeToPDBFile(String)}</code>. The method
	 * does not create a PDB file, if a file having the same name already exists.
	 * @throws SQLException
	 * @throws PdbCodeNotFoundException
	 * @throws PdbLoadError
	 * @throws IOException
	 */
	public void dumpToPDBFile () throws SQLException, PdbCodeNotFoundException, PdbLoadError, IOException{
		String title = new String (pdb_dir + name + ".pdb");
		File pdbfile = new File (title);
		if(!pdbfile.exists()){
			MySQLConnection conn = new MySQLConnection ();
			Pdb pdb = new PdbasePdb(name, "pdbase_20090728", conn);
			pdb.load("A");
			pdb.writeToPDBFile(title);
		}
		else{
			System.err.println(title + " file already exists...");
		}
	}
	
	/*------------------------------------------------------Getter-----------------------------------------------*/
	/**
	 * Getter: returns the field <code>{@link #movieframekeeper}</code>.
	 * @return
	 */
	public HashMap<String,HashSet<String>> getMovieFrameKeeper (){
		if(movieframekeeper != null){
			return new HashMap<String,HashSet<String>> (movieframekeeper);
		}
		else{
			throw new NullPointerException ("The field 'movieframekeeper was not initialized!");
		}
	}
	
	/**
	 * File reader method: reads the <code>i</code>-th file in the field <code>{@link #filelist}</code> and 
	 * converts it to a String represented by the field <code>{@link #filecontent}</code>.
	 * @deprecated Since the method <code>{@link #readFiles(int, String)}</code> does pretty much the same and can write
	 * commands for a better presentation of the evolutionary run, this method should not be used.
	 * @param i the i-th file in <code>filelist</code>
	 * @return
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	@Deprecated
	public String readFiles (int i) throws FileNotFoundException, IOException {
		if(filelist[i].isFile() && filelist[i].getName().contains(".cmap")){
			String lines = "", linereader = "", selector = "Sel", pdbcode = "";
			String filename = filelist[i].getName(), dir = filelist[i].getAbsolutePath();
			int counter = 0, contactcounter = 0;
			BufferedReader reader = new BufferedReader (new FileReader (filelist[i]));
			HashSet<Pair<Integer>> set = new HashSet<Pair<Integer>> ();
			while((linereader = reader.readLine()) != null){
				if(linereader.contains("#")){
					if(linereader.contains("PDB") && !linereader.contains("CHAIN")){
						pdbcode = linereader.split(": ")[1];
						name = pdbcode;
						lines = "load " + dir.replace(filename, "") + pdbcode + ".pdb\n";
					}
					if(linereader.contains("NUMB. OF CONTS. IN POP")){
						contactcounter = (int) Double.parseDouble(linereader.split(": ")[1]);
					}
				}
				else{
					if(linereader.contains("\t")){
						if(counter == 0){
							lines += "hide lines\nshow cartoon\ndisable all\nenable "+pdbcode+"\ncolor pink\norient "+pdbcode+"\ndisable all\nenable "+pdbcode+"\nenable "+pdbcode+"\n";
						}
						int fval = (int) Double.parseDouble(linereader.split("\t")[0]);
						int sval = (int) Double.parseDouble(linereader.split("\t")[1]);
						Integer firstval = new Integer (fval), secval = new Integer (sval);
						Pair<Integer> pair = new Pair<Integer> (firstval, secval);
						set.add(pair);
						selector = "Sel1_"+pdbcode;
						lines += "distance "+selector+", "+pdbcode+" and resi "+fval+" and name ca, "+pdbcode+" and resi "+sval+" and name ca\n";
						counter++;
					}
				}
			}
			lines += "hide labels, "+selector+"\ncolor magenta, "+selector+"\nhide lines, "+selector+"\nselect Sel" + pdbcode + "_Nodes, "+deleteNonContacts (set) + "\ngroup Sel1, "+selector+" Sel"+pdbcode+"_Nodes\n" +
					"mset 1 x60\nutil.mroll(1,60,1)\n# "+contactcounter+"\n";
			return lines;
		}
		else{
			throw new IllegalArgumentException ("This denoted file is not a 'contact map file with extention 'cmap'!!");
		}
	}
	
	/**
	 * File reader method: reads the <code>i</code>-th file in the field <code>{@link #filelist}</code> and 
	 * converts it to a String represented by the field <code>{@link #filecontent}</code>. In case the readable files
	 * do not contain any information about the generation, the file ordering must be consistent with the occurence
	 * of the <code>i</code>-th file in an evolutionary context.
	 * @param i
	 * @param dummy
	 * @return
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	public String readFiles (int i, String dummy) throws FileNotFoundException, IOException {
		if(movieframekeeper == null){
			//check, whether this field is initialized
			
			movieframekeeper = new HashMap<String,HashSet<String>> ();
		}
		String lines = "", linereader = "", selector = "Sel", pdbcode = "";
		int counter = 0, helpcounter = 0;
		if(i > 0){
			//the field 'frameindices', counting all frames belonging to one generation
			
			helpcounter = frameindices[i - 1];
		}
		BufferedReader reader = new BufferedReader (new FileReader (filelist[i]));
		HashSet<Pair<Integer>> set = new HashSet<Pair<Integer>> ();
		HashSet<String> movieframes = new HashSet<String> ();
		//a HashSet containing all distance slection expressions of this readable file
		
		while((linereader = reader.readLine()) != null){
			//loop, until the end of file is reached
			
			if(linereader.contains("#")){
				//header of file contains info, starting with '#'
				
				if(i == 0){
					//only for the first file in the list 'filelist', the PDB code must be read, after that is not necessary
					
					if(linereader.contains("PDB") && !linereader.contains("CHAIN")){
						pdbcode = linereader.split(": ")[1];
						name = pdbcode;
						//initializing the field 'name' representing the PDB code of the protein,
						
						lines = "load " + pdb_dir + pdbcode + ".pdb\n";
					}
				}
				else{
					if(name != null && pdbcode.isEmpty()){
						//after the first run, the field 'name' is used
						
						pdbcode = name;
					}
				}
				if(linereader.contains("GENERATION")){
					//in case the the files contain any information about the generation
					
					int gen_num = (int) Double.parseDouble(linereader.split(": ")[1]);
					generation_indeces[i] = gen_num;
				}
			}
			else{
				if(linereader.contains("\t")){
					//the contact table contains tabs, separating the first and second value of the contact
					
					if(counter == 0 && i == 0){
						//the initial line in the 'pml' file contains the String below, commanding PyMol to load and modify the specific protein
						
						lines += "hide lines\nshow cartoon\ndisable all\nenable "+pdbcode+"\ncolor pink\norient "+pdbcode+"\ndisable all\nenable "+pdbcode+"\nenable "+pdbcode+"\n";
					}
					int fval = (int) Double.parseDouble(linereader.split("\t")[0]);
					//first contact value
					
					int sval = (int) Double.parseDouble(linereader.split("\t")[1]);
					//second contact value
					
					Integer firstval = new Integer (fval), secval = new Integer (sval);
					Pair<Integer> pair = new Pair<Integer> (firstval, secval);
					//a Pair instance containing both values
					
					set.add(pair);
					selector = "Sel"+(helpcounter + counter)+"_"+pdbcode;
					//selection expression
					
					movieframes.add(selector);
					lines += "distance "+selector+", "+pdbcode+" and resi "+fval+" and name ca, "+pdbcode+" and resi "+sval+" and name ca\n";
					//distance selection command: commanding PyMol to create a distance selection between two residues
					
					double frequencies = Double.parseDouble(linereader.split("\t")[2]);
					//the frequencies of the contact in the Population
					
					String color = "";
					//coloring of the current distance selection will be specified by this String
					
					if(frequencies < 0.25){
						//below 25 %, meaning this contact has a frequency of less than one fourth
						
						color = "blue";
					}
					else{
						if(frequencies < 0.5){
							//between 25 % and 50 %
							color = "green";
						}
						else{
							if(frequencies < 0.75){
								//between 50 % and 75 %
								color = "yellow";
							}
							else{
								//above 75 %, meaning this contact has a frequency of more than three fourth
								color = "red";
							}
						}
					}
					lines += "set dash_width, " + (frequencies * 9.0) + ", " + selector + "\nset dash_gap, 0\nhide labels\ncolor " + color + ", " + selector + "\n";
					//setting the distance dash width to the value specified by the frequency of the contact in this population, if the Population only consists of
					//Individuals output ('indi' or 'ust' files), the width and coloring will be the same
					
					counter++;
				}
			}
		}
		Integer value = new Integer (0);
		String sel = "Sel";
		if(generation_indeces[i] != -1){
			value = new Integer (generation_indeces[i]);
		}
		else{
			value = new Integer (i);
		}
		sel += value;
		movieframekeeper.put(sel, movieframes);
		//all distance selection expressions were stored in the local variable 'movieframes', which in turn is used to group together all selection expressions
		//and are placed in the field 'movieframekeeper'
		
		String deselector = "";
		for(int j = 0; j < counter; j++){
			//a deselection loop, writting a deselection command to the 'pml' file
			
			deselector = "Sel" + (helpcounter + j) + "_" + pdbcode;
			lines += "hide dashes, " + deselector + "\n";
		}
		frameindices[i] = helpcounter + counter;
		//lines += "# "+(helpcounter + contactcounter)+"\n";//"hide labels, "+selector+"\ncolor magenta, "+selector+"\nhide lines, "+selector+"\nselect Sel" + pdbcode + "_Nodes, "+deleteNonContacts (set) + "\ngroup Sel1, "+selector+" Sel"+pdbcode+"_Nodes\n" +
		//"mset "+ (i + 1) +" x60\nutil.mroll(1,60,1)\n# "+(helpcounter + contactcounter)+"\n";
		return lines;
	}
	
	/**
	 * Returns the group selection of each set of contacts (distances) belonging to one generation.
	 * @return
	 * @throws NullPointerException
	 */
	public String getGrouping () throws NullPointerException {
		if(grouping != null){
			return new String (grouping);
		}
		else{
			throw new NullPointerException ("The field 'grouping was not initialized!");
		}
	}
	
	/*public String[] getGroupingAsStringArray(){
		if(grouping != null){
			int length = grouping.split(",").length;
			String[] array = new String[length];
			for(int i = 0; i < array.length; i++){
				array[i] = new String(grouping.split(",")[0]);
				array[i].replaceAll("group ")
			}
		}
	}*/
	/*--------------------------------------------------------statics---------------------------------------------*/
	/**
	 * method removing all non directories from the file list. 
	 * @param list
	 * @return only directories in this file list
	 */
	public static File[] onlyListDirectories (File[] list){
		int length = list.length, counter = 0, counterb = 0;
		boolean[] testarray = new boolean[length];
		for(int i = 0; i < length; i++){
			if(list[i].isDirectory()){
				testarray[i] = true;
				counter++;
			}
		}
		File[] newlist = new File[counter];
		for(int i = 0; i < length; i++){
			if(testarray[i]){
				newlist[counterb] = new File(list[i].getAbsolutePath());
				counterb++;
			}
		}
		return newlist;
	}
	
	/**
	 * method removing non readable files from the <code>{@link #filelist}</code> field.
	 * @param filist
	 * @return
	 */
	public static File[] removeNonCMapFiles (File[] filist){
		if(filist != null){
			int length = filist.length, counter = 0, counterb = 0;
			boolean[] testarray = new boolean [length];
			for(int i = 0; i < length; i++){
				if(isCMapFile(filist[i])){
					testarray[i] = true;
					counter ++;
				}
			}
			File[] newlist = new File[counter];
			for(int i = 0; i < length; i++){
				if(testarray[i]){
					newlist[counterb] = new File (filist[i].getAbsolutePath());
					counterb++;
				}
			}
			Arrays.sort(newlist);
			return newlist;
		}
		else{
			throw new NullPointerException ("This file list does not exist!!");
		}
	}
	
	/**
	 * This method sets the file type accepted by this class. The accepted types of files
	 * must have the extension <code>.cmap, .indi</code> or <code>.ust</code>.
	 * @param dir - File instance, denoting the 
	 * @throws IllegalArgumentException if the denoted directory does not contain any acceptable files
	 * or does not exist.
	 */
	public static void setFileType (File dir) throws IllegalArgumentException {
		if(dir.exists()){
			for(int i = 0; i < 3; i++){
				File[] filel = dir.listFiles(new RegexFileFilter (file_types[i]));
				if(filel.length > 0){
					file_type = new String (file_types[i]);
					break;
				}
			}
			if(file_type == null){
				throw new IllegalArgumentException ("The denoted directory did not contain any readable file...");
			}
		}
		else{
			throw new IllegalArgumentException ("The denoted directory does not exist...");
		}
	}
	
	/**
	 * method checking <code>dirs</code> whether or not it contains a <code>.cmap, .indi</code> or <code>.ust</code> file.
	 * @param dirs
	 * @return true if <code>dirs</code> contains at least one contact map file
	 */
	public static boolean containsCMapFiles (File dirs){
		if(file_type == null){
			setFileType(dirs);
		}
		File subfile = new File (dirs.getAbsolutePath());
		File[] list = subfile.listFiles(new RegexFileFilter(file_type));
		if(list.length == 0){
			return false;
		}
		else{
			return true;
		}
	}
	
	/**
	 * method, to copy File instances to a new array of File instances,
	 * @param src the source array of File instances
	 * @param dest the destination array of File instances
	 */
	public static void copyFiles (File[] src, File[] dest){
		int srclength = src.length, destlength = dest.length;
		if(srclength == destlength){
			for(int i = 0; i < srclength; i++){
				dest[i] = new File(src[i].getAbsolutePath());
			}
		}
	}
	
	/**
	 * method checking whether the denoted File is an acceptable/readable file.
	 * @param file
	 * @return
	 */
	public static boolean isCMapFile (File file){
		String name = file.getName();
		if(file_type != null){
			if(name.contains(file_type)){
				return true;
			}
			else{
				return false;
			}
		}
		else{
			throw new NullPointerException ("The member 'file_type' was not initialized...");
		}
	}
	
	/**
	 * method, to group all distances together in the 'pml' file. This is, that all distances
	 * are grouped together to simultaneously alter them after having them selected. This method is
	 * only used by <code>{@link #readFiles(int)}</code>.
	 * @param set
	 * @return
	 */
	public static String deleteNonContacts (HashSet<Pair<Integer>> set){
		if(set.size() > 0){
		int[][] array = SortIntArray.converter(set);
		int length = array[0].length;
		int[] helper1 = new int[length];
		int[] helper2 = new int[length];
		System.arraycopy(array[0], 0, helper1, 0, length);
		System.arraycopy(array[1], 0, helper2, 0, length);
		Arrays.sort(helper1);
		Arrays.sort(helper2);
		String conts1 = "(", conts2 = "(";
		conts1 += helper1[0];
		conts2 += helper2[0]; 
		for(int i = 1; i < length - 1; i++){
			if(helper1[i] + 1 != helper1[i + 1] && helper1[i] != helper1[i + 1]){
				conts1 += "-" + helper1[i] + "," + helper1[i + 1];
			}
			if(helper2[i] + 1 != helper2[i + 1] && helper2[i] != helper2[i + 1]){
				conts2 += "-" + helper2[i] + "," + helper2[i + 1];
			}
		}
		if(helper1[length - 2] != helper1[length - 1]){
			conts1 += "-"+helper1[length - 1] + ") or ";
		}
		if(helper2[length - 2] != helper2[length - 1]){
			conts2 += "-"+helper2[length - 1] + ")";
		}
		return (conts1 + conts2);
		}
		else{
			throw new IllegalArgumentException ("Parameter set must always have more than zero entries!!");
		}
	}
	
	public static String getLastContactNumber (String str){
		if(str.contains("#")){
		int length = str.split("#").length;
		return str.split("#")[length - 1];
		}
		else{
			return "";
		}
	}
	
	public static File[] dirListing (File dir) throws IOException{
		//if(dir.exists() && dir.isDirectory()){
			File[] list = dir.listFiles();
			list = onlyListDirectories(list);
			int counter = 0, length = list.length, counter1 = 0;
			boolean[] tester = new boolean[length];
			for(int i = 0; i < list.length; i++){
				if(containsCMapFiles(list[i])){
					tester[i] = true;
					counter++;
				}
			}
			File[] cmapdirlist = new File[counter];
			for(int i = 0; i < length; i++){
				if(tester[i]){
					cmapdirlist[counter1] = new File(list[i].getAbsolutePath());
					counter1++;
				}
			}
			Arrays.sort(cmapdirlist);
			return cmapdirlist;
		/*}
		else{
			if(!dir.exists()){
				throw new IOException ("The directory '"+dir.getAbsolutePath()+"' does not exist.");
			}
			else{
				if(!dir.isDirectory()){
					throw new IllegalArgumentException("The directory '"+dir.getAbsolutePath()+"' is not a directory.");
				}
			}
		}*/
	}
	public static File[] multiRun (String superdir){
		File file = new File(superdir);
		if(file.exists()&&file.isDirectory()){
			File[] demelist = file.listFiles(new RegexFileFilter("deme.*"));
			int length = demelist.length;
			File[] dirlist = new File[length];
			for(int i = 0; i < length; i++){
				dirlist[i] = new File(demelist[i].getAbsolutePath()+"/evo2/");
			}
			return dirlist;
		}
		else throw new IllegalArgumentException ("No such directory!");
	}
	
	public static void main (String[] args) throws FileNotFoundException, IOException, SQLException, PdbCodeNotFoundException, PdbLoadError{
		String[] pdbs = {"1bkr","1e0l","1e6k","1o8w","1odd","1onl","1pzc","1r9h","1sha","1ugm"};
		String dir    = "/project/StruPPi/gabriel/Arbeiten/180310/run0";
		for(int i = 0; i < 5; i++){
			for(int j = 0; j < pdbs.length; j++){
				File[] list = multiRun(dir+i+"/"+pdbs[j]+"/");
				int length = list.length;
				CMGrabber[] cm = new CMGrabber[length];
				for(int k = 0; k<length;k++){
					cm[k] = new CMGrabber(list[k],120);
					cm[k].printToFile();
				}
			}
		}
		/*File[] list = dirListing(dirs);
		int length = list.length;
		CMGrabber[] array = new CMGrabber[length];
		for(int i = 0; i < length; i++){
			array[i] = new CMGrabber(list[i],120);
			array[i].printToFile();
		}*/
	}
}
