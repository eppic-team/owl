package embed.contactmaps;

import java.io.*;
import java.util.*;

import edu.uci.ics.jung.graph.util.Pair;

import tools.RegexFileFilter;

/**
 * This class deals with neighbourhood strings generated by the class <code>{@link #NeighbourhoodString}</code>. Each neighbourhood string 
 * represents an amino acid having contacts to amino acids denoted by the single lettre code. The percentage sign '%' denotes wildcard indicating
 * that each contacting amino acid does not necessarily neighbours the actual amino acid. Since the class <code>{@link #NeighbourhoodString}</code>
 * never merges the output of an individual run, especially the initial generation will always generate multiple output. That's why this auxiliary class
 * was implemented. Most of the methods defined in this class are private, except for <code>{@link #toString()}</code> and <code>{@link #writeToFile(String, String)}</code>. 
 * @author gmueller
 *
 */
public class MergeOutPut {
	
	/*-------------------------------------------fields--------------------------------------------*/
	
	
	/**
	 * a String instance denoting the abstract path of a directory containing output files of the <code>{@link #NeighbourhoodString}</code> class
	 */
	private String path;
	
	/**
	 * a String instance representing the content of all neighbourhood string files
	 */
	private String content;
	
	/**
	 * content map: contains all indices and their corresponding Strings (i.e. single lettre code), representing contacts 
	 */
	private HashMap<Pair<Integer>,String> content_map;
	
	
	/**
	 * content surveillance: checks, whether a given contact is already present in the content_map, if and only if the contact is not
	 * present, yet, it will be stored in the field content_map.
	 */
	private HashMap<Integer,Pair<Integer>> cont_surv;
	
	/**
	 * file system: listing all 'out' files, which is the standard output format of the <code>{@link #NeighbourhoodString}</code> class.
	 */
	private File[] file_sys;
	
	/*--------------------------------------------------constants---------------------------------------------------------*/
	/**
	 * the standard file output format: 'out'
	 */
	private static final String file_format = "out";
	
	
	/*--------------------------------------------------constructor-------------------------------------------------------*/
	
	
	/**
	 * One parameter constructor: initializes an MergeOutPut object.
	 * @param dir_str: a String denoting the absolute path of a directory containing the 'out' files to be processed 
	 */
	public MergeOutPut (String dir_str) throws FileNotFoundException, IOException{
		setMergeOutPut(dir_str);
	}
	/*-------------------------------------------------setter---------------------------------------*/
	
	/**
	 * initializing setter: called by the one parameter constructor. Firstly, it checks, whether the denoted directory
	 * contains 'out' files. Thereafter, a listing of all 'out' files takes place and the content of each file is read
	 * and stored in the concerning fields and merged together.
	 * @param dir_str - a String denoting the directory
	 * @throws FileNotFountException
	 * @throws IOException
	 * @throws IllegalArgumentException if the denoted directory either does not exist or does not contain any files with ".out" extension
	 * 
	 */
	private void setMergeOutPut(String dir_str) throws FileNotFoundException, IOException, IllegalArgumentException {
		File dir = new File (dir_str);
		if(dir.exists()){
			//check, whether the directory exists
			
			File[] list = dir.listFiles(new RegexFileFilter (".*."+file_format));
			//listing all files with extension 'out'
			
			int length = list.length;
			if(length > 0){
				//only if the number of 'out' files is greater than zero, the method proceeds
				
				path = new String (dir.getAbsolutePath());
				//the path field initialized
				
				file_sys = new File[length];
				//file system initialized
				
				System.arraycopy(list, 0, file_sys, 0, length);
				//copying all files from the list
				
				readFileSys();
				//reading the 'out' files
				
				mergeContent();
				//merging content
			}
			else{
				throw new IllegalArgumentException ("The denoted path = '"+path+"' does not contain any readable files.");
				//if the directory does not contain any 'out' files
			}
		}
		else{
			throw new IllegalArgumentException ("The denoted path = '"+path+"' does not exist.");
			//if the directory does not exist
		}
	}
	
	/*-------------------------------auxiliaries----------------------------------------------*/
	/**
	 * merging the content of all files listed in the field <code>{@link #file_sys}</code>, so one output files is
	 * yielded.
	 * @throws NullPointerException if the field <code>{@link #content_map}</code> was not initialized before calling this method
	 */
	private void mergeContent (){
		if(content_map != null){
			//check, whether the field content_map was initialized
			
			HashMap<Pair<Integer>,String> copy = getContentMap();
			//a copy of the content_map field
			
			content = "";
			//initializing the field content
			
			Set<Pair<Integer>> keyset = copy.keySet();
			HashSet<Pair<Integer>> hash = new HashSet<Pair<Integer>> (keyset);
			int[][] entry_array = SortIntArray.converter(hash);
			//converting the HashSet<Pair<Integer>> to an sorted array of integer
			
			int length = entry_array[0].length;
			for(int i = 0; i < length; i++){
				//iterating over all sorted entries
				
				int f_val = entry_array[0][i], s_val = entry_array[1][i];
				//first and second value of the HashSet
				
				Pair<Integer> pair = new Pair<Integer> (new Integer(f_val),new Integer (s_val));
				//converting it to a Pair instance
				
				content += copy.get(pair) + "\n";
				//store it in copy
			}
		}
		else{
			throw new NullPointerException ("The field content_map must be initialized before calling this method.");
		}
	}
	
	/**
	 * method, that reads all files listed in the field <code>{@link #file_sys}</code> and converts its
	 * content to a String that is stored in <code>{@link #content_map}</code> and <code>{@link #content}</code>.
	 * @throws FileNotFoundException
	 * @throws IOException
	 * @throws IllegalArgumentException if the field <code>{@link #file_sys}</code> does not contain any '.out' files
	 * @throws NullPointerException if the field <code>{@link #file_sys}</code> was not initialized before calling this method
	 */
	private void readFileSys () throws FileNotFoundException, IOException, IllegalArgumentException, NullPointerException {
		if(file_sys != null && file_sys.length > 0){
			//check, whether both fields were initialized before calling this method
			
			int length = file_sys.length, counter = 1, counterb = 1;
			//number of files listed in file_sys
			
			content_map = new HashMap<Pair<Integer>,String> ();
			cont_surv = new HashMap<Integer,Pair<Integer>> ();
			//initializing both fields
			
			for(int i = 0; i < length; i++){
				//iterating over all file_sys entries
				
				BufferedReader reader = new BufferedReader (new FileReader (file_sys[i]));
				String linereader = "";
				while((linereader = reader.readLine()) != null){
					//reading the files until the String instance 'linereader' is null (equivalently the end of the file)
					
					if(!content_map.containsValue(linereader)){
						//if the content is not present yet, proceed
						
						int index_val = (int) (Double.parseDouble(linereader.split("\t")[2]));
						//third column contains the residue number
						
						Integer int_val = new Integer (index_val), one = new Integer (1);
						if(!content_map.containsKey(new Pair<Integer>(int_val,one))){
							//check, whether the contact is not already present, if so meaning the neigbourhood string is not present, yet,
							//then the contact gets an id, which is composed of the residue number and the number of occurrence in all contact map
							//represented by the whole population. in this case, of course: residue id, 1!
							
							Pair<Integer> pair = new Pair<Integer> (int_val,new Integer(1));
							content_map.put(pair, linereader);
							cont_surv.put(new Integer(counterb), pair);
							counterb++;
						}
						else{
							Pair<Integer> pair = new Pair<Integer>(int_val,new Integer(counter));
							while(cont_surv.containsValue(pair)){
								counter++;
								pair = new Pair<Integer> (int_val,new Integer (counter));
							}
							content_map.put(pair, linereader);
							cont_surv.put(new Integer (counterb), pair);
							counterb++;
						}
					}
				}
			}
		}
		else{
			if(file_sys.length > 0){
				throw new IllegalArgumentException ("The denoted path did not contain any files with extension '.out'");
			}
			else{
				throw new NullPointerException ("The field 'file_sys' was not initialized before calling this method.");
			}
		}
	}
	
	/**
	 * Output method: simply writes the field <code>{@link #content}</code> to a file and/or directories,
	 * specified by the two parameters.
	 * @param sub_dir absolute path of an output sub-directory
	 * @param output_name the name of the output file
	 * @throws IOException
	 */
	protected void writeToFile (String sub_dir, String output_name) throws IOException{
		File dir = new File (path + sub_dir);
		if(!dir.exists()){
			//check, whether the denoted directory exists, if not, the method mkdirs() of the File class
			//is called to create a new directory
			
			dir.mkdirs();
		}
		FileOutputStream out = new FileOutputStream (path + sub_dir + output_name);
		PrintStream printa = new PrintStream (out);
		printa.print(toString());
		//writing the content to a single file
		
		System.out.println("Content written to file...");
		out.close();
		printa.close();
	}
	
	/**
	 * returns the field <code>{@link #content_map}</code> as a HashMap.
	 * @return
	 */
	private HashMap<Pair<Integer>,String> getContentMap (){
		return new HashMap<Pair<Integer>,String> (content_map);
	}
	
	/**
	 * method, returning the field <code>{@link #content}</code> as a String.
	 */
	public String toString (){
		return new String (content);
	}
	
	public static void main (String[] args) throws FileNotFoundException, IOException{
		String dir = "/project/StruPPi/gabriel/Arbeiten/run_051109/1sha/Starter/nbhstrings/";
		MergeOutPut put = new MergeOutPut(dir);
		put.writeToFile("/merge/","run_051109.out");
	}

}
