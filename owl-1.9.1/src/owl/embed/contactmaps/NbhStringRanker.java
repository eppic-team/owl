package owl.embed.contactmaps;

import java.sql.*;
import java.util.*;
import java.io.*;

import owl.core.structure.PdbCodeNotFoundException;
import owl.core.structure.PdbLoadError;
import owl.core.util.RegexFileFilter;

import edu.uci.ics.jung.graph.util.Pair;


//import tools.*;

/**
 * A class dealing with neighborhood Strings. All these neighborhood Strings are generated by the inner class
 * <code>{@link NhbString}</code>, and put in a <tt>.out</tt> file. If such
 * files do not exist, the class 1-parameter constructor issues an IllegalArgumentException or FileNotFoundException.
 * So any use of this class for an other file type must implement this class as a superclass and override the initial
 * setter method <code>{@link #setNbhStringMaps(String, String)}</code>. It is important to notice, that the parameter
 * of this constructor is a String denoting the directory containing all the neighborhood String files.
 * <p>
 * </p>
 * <p>
 * </p>
 * <p>
 * To facilitate usage of this class, one can optionally circumvent an intermediate output of text files by using the inner class <code>{@link NhbString}</code>.
 * 
 * The inner class <code>{@link NhbString}</code> provides essential methods as converting contact map files (which are 
 * specified in the class <code>{@link Individuals}</code>) to neighborhood Strings. So, any implementation of this class
 * should look like:
 * </p>
 * <p>
 * <tt> NbhStringRanker rk = new NbhStringRanker();</tt>
 * </p>
 * <p>
 * <tt> NeighbourhoodString nbh_str = rk.new NeighbourhoodString (dir)</tt>
 * </p>
 * <p>
 * <tt> rk.setNbhRanker(nbh_str);</tt>
 * </p>
 * <p>
 * <tt>	rk.runQueries();</tt>
 * </p>
 * <p>
 * <tt>	rk.writeToFile(String,String);</tt>
 * </p>
 * <p>
 * <tt>	rk.close();</tt>
 * </p>
 * <p>
 * The parameter <tt>dir</tt> is a String instance denoting a directory, that contains all contact map files. So, firstly, an <code>{@link NhbStringRanker}</code>
 * instance is created, followed by the creation of a <code>{@link NhbString}</code> instance. The method <code>{@link NhbStringRanker#setNbhRanker(NhbString)}</code>
 * transfers fields from the inner class to the outer class, without writing them to an external file.
 * </p>
 * <p>
 * The output of this class is a String in table format, which in turn can be written to a text file by the implemented
 * <code>{@link #writeToFile(String,String)}</code> method. The format is:
 * </p>
 * <p>
 * <table>
 * <tr>pdb code</tr><tr>single letter aa code + position</tr><tr>occurrence</tr><tr>position within the table (i out of twenty)</tr></table></p>,
 * <p>
 * iff the amino acid is present in the query result. In case of no entry, the occurrence is set to zero and the position is set to 21 (meaning no such
 * record).
 * </p>  
 * @author gmueller
 * @see <code>{@link NhbString}</code> in order to see the standard output of the mentioned class
 * @see <code>{@link Individuals#Individuals(String)}</code>, <code>{@link Demes#printToFile(String,String)}</code> or <code>{@link Species#printToFile(String,String)}</code> to see
 * standard contact map file format
 *
 */
public class NbhStringRanker extends owl.core.util.MySQLConnection {
	
	/*---------------------------------------------------members-----------------------------------------------------*/
	
	/*--------------------------------------------------constants----------------------------------------------------*/
	/**
	 * command leader: a constant String instance giving the first part of the SQL query
	 */
	private static final String command_leader    = "select res, count(*) AS c from cullpdb_20.nbstrings where f LIKE '";
	
	/**
	 * command trailer: a constant String instance giving the final part of the SQL query
	 */
	private static final String command_trailer   = "' group by  res order by c desc;";
	
	/*---------------------------------------------------fields------------------------------------------------------*/
	
	/**
	 * a String HashMap, where the key is the single letter amino acid code plus its position within the sequence and
	 * the value is the neighborhood String. It only reads the files, that do not match the final population neighborhood
	 * String files
	 */
	HashMap<String,HashSet<String>> aa_nbh_map;
	
	/**
	 * a TreeMap containing all positions occurring in the neighborhood String map as key and maps them
	 * onto the single letter amino acid code. 
	 */
	TreeMap<Integer,String> aa_map;
	
	/**
	 * the pdb code of the protein, if the pdb codes of two different neighborhood String files do not match, the <code>{@link #setNbhStringMaps(String, String)}</code> throws
	 * an <code>IllegalArgumentException</code>.
	 */	
	String pdb_code;
	
	/**
	 * the content, listing the results from all queries
	 */
	private String content;
	
	
	/*-------------------------------------------------constructors--------------------------------------------------*/
	/**
	 * Zero-parameter constructor: pretty much does not do anything
	 */
	public NbhStringRanker () throws SQLException{
		super();		
	}
	
	/**
	 * Two-parameter constructor: this is the most important constructor. It uses a String parameter to
	 * define the directory containing the neighborhood String files, which in turn will be listed in a File array.
	 * The second parameter specifies the final neighborhood String file, which is equivalent to the last generation in the evolutionary run from
	 * any of the classes <code>{@link Individuals}</code>, <code>{@link Demes}</code> or <code>{@link Species}</code> in the embed package.
	 * @param dir a String denoting the directory of the neighborhood String files
	 * @param final_generation the neighborhood String file of the last generation
	 * @throws FileNotFoundException
	 * @throws IOException
	 * @throws SQLException
	 * @throws IllegalArgumentException
	 */
	public NbhStringRanker (String file_name) throws FileNotFoundException, IOException, SQLException, IllegalArgumentException {
		super();
		setNbhStringMaps(file_name);
	}
	
	/**
	 * initial setter: reads all specified neighborhood String files (nbh files, with '.out' extension) and
	 * converts them to a HashMap, where the key is single letter amino acid code plus the position within the
	 * peptide chain and value is the actual neighborhood String. In case of
	 * neighborhood String files in different format, one has to implement this class as superclass and must (!) override this method,
	 * otherwise an Exception may occur.
	 * @param dir String denoting the absolute path of the directory, where all neighborhood String files are
	 * stored
	 * @param final_generation the file name of the final generation neighborhood String file
	 * @throws IOException the denoted directory does not exist
	 * @throws FileNotFoundException files do not exist
	 * @throws IllegalArgumentException
	 */
	public void setNbhStringMaps (String file_name) throws IOException, FileNotFoundException, IllegalArgumentException {
		File file = new File (file_name);
		if(file.exists()){
			//check, whether the directory exists
			
			aa_map = new TreeMap<Integer,String> ();
			
			setAANbhStringMaps(file);
			
		}
		else{
			throw new IllegalArgumentException ("There are no neighborhood String files, please make sure at least one neighborhood String file is present in the denoted directory.");
			//if the File array has no entries, an exception is thrown
			
		}
	}
	
	/**
	 * auxiliary method: this is the actual reader method, reading the neighborhood String files, converts
	 * them to a <code>{@link HashMap}</code> and stores them in the field:
	 * <p>
	 * </p>
	 * <p>
	 * <code>{@link #aa_nbh_map}</code>: the neighborhood String map of the initial generation
	 * </p>
	 * @param file a File instance representing the neighborhood String file
	 * @param final_vs_random determines, where to store the HashMap, if <tt>true</tt>, then the
	 * <code>{@link #aa_nbh_map_final}</code> will be used, otherwise <code>{@link #aa_nbh_map}</code> 
	 * @throws IOException
	 * @throws FileNotFoundException
	 * @throws IllegalArgumentException if two pdb codes do not match
	 */
	private void setAANbhStringMaps(File file) throws IOException, FileNotFoundException, IllegalArgumentException {
		BufferedReader reader = new BufferedReader (new FileReader (file));
		String linereader = "";
		HashMap<String,HashSet<String>> str_map = new HashMap<String,HashSet<String>> ();
		//the neighborhood String map
		
		while((linereader = reader.readLine()) != null){
			//reading the file
			
			String[] str_array = linereader.split("\t");
			//splitting the line reader, first column: pdb code, second column: chain code, third column: position,
			//fourth column: neighborhood String
			
			if(pdb_code == null){
				//check, whether the field 'pdb_code' was not initialized, yet
				
				pdb_code = new String (str_array[0]);
				String f_val = str_array[3] + str_array[2];
				//first value = key: amino acid code + position
				
				String s_val = str_array[4];
				//neighborhood String
				
				if(str_map.containsKey(f_val)){
					HashSet<String> str_set = str_map.get(f_val);
					str_set.add(s_val);
					str_map.put(f_val, str_set);
				}
				else{
					HashSet<String> str_set = new HashSet<String> ();
					str_set.add(s_val);
					str_map.put(f_val, str_set);
				}
				//place both key and value in the HashMap
				
				Integer aa_index = new Integer ((int) Double.parseDouble(str_array[2]));
				aa_map.put(aa_index, str_array[3]);
				
			}
			else{
				//if the field 'pdb_code' was initialized before
				
				if(str_array[0].matches(pdb_code)){
					//check, whether both pdb code match, if not an IllegalArgumentException is
					//thrown
					
					String f_val = str_array[3] + str_array[2];
					//first value = key: amino acid code + position
					
					String s_val = str_array[4];
					//neighborhood String
					
					if(str_map.containsKey(f_val)){
						HashSet<String> str_set = str_map.get(f_val);
						str_set.add(s_val);
						str_map.put(f_val, str_set);
					}
					else{
						HashSet<String> str_set = new HashSet<String> ();
						str_set.add(s_val);
						str_map.put(f_val, str_set);
					}
					
					Integer aa_index = new Integer ((int) Double.parseDouble(str_array[2]));
					aa_map.put(aa_index, str_array[3]);
					
				}
				else{
					throw new IllegalArgumentException ("The pdb codes do not match, please make sure only neighbourhood String files of the same proteins are treated at the same time!!");
				}
			}
		}
		aa_nbh_map = new HashMap<String,HashSet<String>> (str_map);
	}
	
	/**
	 * Supplementary constructor: intended to be used, when ever a set of contact maps need to be converted.
	 * <p>
	 * </p>
	 * <p>
	 * Firstly, all contact map files (for all kinds of file formats excepted, please check the constructor <code>{@link Individuals#Individuals(String)}</code>)
	 * are converted to neighborhood Strings. This is accomplished by calling the one
	 * parameter constructor of the inner class <code>{@link NhbString}</code>. This constructor
	 * automatically converts all contacts present in the contact map file system to a merged String instance
	 * and then transfers all data to this constructor.
	 * </p>
	 * @param nbh_str
	 * @throws SQLException
	 */
	public void setNbhRanker (NhbString nbh_str){
		pdb_code = nbh_str.getPDBCode();
		aa_nbh_map = nbh_str.getContToNbh();
		setAaMap(nbh_str);
		content = nbh_str.toString();
	}
	
	/**
	 * The method, that issues all SQL queries and stores them in the <code>{@link #content}</code> field.
	 *  
	 * @throws SQLException
	 */
	public void runQueries () throws SQLException{
		HashMap<Integer,String> aa_mapping	= getAaMap();
		HashMap<String,HashSet<String>> nbh_map 		= getAaNbhStringMapRandom();
		//getting the neighborhood String maps
		
		Set<Integer> keyset = aa_mapping.keySet();
		Integer[] index_array = new Integer[keyset.size()];
		keyset.toArray(index_array);
		Arrays.sort(index_array);
		content    = "pdb code \t aa \t nbhstring \t occurrance \t rank of 20\n";
		for(int i = 0; i < index_array.length; i++){
			//iterating over all entries
			
			Integer key      = index_array[i];
			String aa		 = aa_mapping.get(key);
			HashSet<String> nbh_set = nbh_map.get(aa + key);
			if(nbh_set != null){
				Iterator<String> it = nbh_set.iterator();
				while(it.hasNext()){
					String nbh_str = it.next();
					Statement stmt;
					ResultSet rs;
					try{
						boolean oc_tester = false;
						stmt = super.createStatement();
						rs = stmt.executeQuery(command_leader + nbh_str + command_trailer);
						//executing the query from the final generation

						while(rs.next()){
							//iterating over the result set tables and check for the matching amino acid

							String str = rs.getString("res");
							if(aa.contains(str)){
								//does the entry match the amino acid key?

								content += pdb_code + "\t" + (aa + key) + "\t"  + nbh_str + "\t" + rs.getString("c") + "\t" + rs.getRow() + "\n";
								//creating the field 'content'

								oc_tester = true;
								break;
							}			
						}
						if(!oc_tester){
							//in case there is no matching entry, that is, when no row contains the matching
							//single aa letter code, the occurrence is set to zero and the rank to 21, mean 
							//no such entry
							
							content += pdb_code + "\t" + (aa + key) + "\t"  + nbh_str + "\t" + 0 + "\t" + 21 + "\n";
						}				
						rs.close();
						stmt.close();
					}
					catch(SQLException e){
						//catching SQL exception

						System.err.println("SQLException: " + e.getMessage());
						System.err.println("SQLState:     " + e.getSQLState());
						System.err.println("VendorError:  " + e.getErrorCode());
						e.printStackTrace();
					}
				}
			}
		}
	}
	
	/**
	 * method writing the field <code>{@link #content}</code> to a text file.
	 * @param dir a String denoting the output directory
	 * @param file_name the file name
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	public void writeToFile (String dir, String file_name) throws FileNotFoundException, IOException {
		File file = new File (dir);
		if(!file.exists()){
			file.mkdirs();
		}
		FileOutputStream output = new FileOutputStream (file + "/" + file_name + ".nbh");
		PrintStream printer     = new PrintStream    (output);
		printer.print(toString());
		System.out.println("Content of " + file_name + " written to file...");
		printer.close();
		output.close();
	}
	
	/**
	 * auxiliary setter: gets the field <code>{@link NhbString#sequence}</code> and transfers
	 * it the field: <code>{@link #aa_map}</code>.
	 * @param nbh_str
	 */
	public void setAaMap (NhbString nbh_str){
		aa_map = new TreeMap<Integer,String> (nbh_str.getSequence());
	}
	
	
	/*----------------------------------------------------getters----------------------------------------------------*/
	
	/**
	 * method returning the field <code>{@link #aa_map}</code>. The key is the position
	 * of the amino acid in the primary sequence and the value is the single letter aa code.
	 * @return the amino acid sequence as a HashMap
	 */
	protected HashMap<Integer,String> getAaMap (){
		return new HashMap<Integer,String> (aa_map);
	}
	
	/**
	 * method that returns a new HashMap instance of the field <code>{@link #aa_nbh_map}</code>
	 * @return a new HashMap of the neighborhood Strings of the random set
	 */
	protected HashMap<String,HashSet<String>> getAaNbhStringMapRandom (){
		return new HashMap<String,HashSet<String>> (aa_nbh_map);
	}
	
	/**
	 * method that returns the field <code>{@link #content}</code> as a new String instance
	 */
	public String toString (){
		return new String (content);
	}
	
	public static void main (String[] args) throws FileNotFoundException, IOException, SQLException, PdbCodeNotFoundException, PdbLoadError{
		String dira  = "/project/StruPPi/gabriel/Arbeiten/run_031209/2nd_run/";
		String dirb  = "/deme0/";
		String dirc  = "/sathyas_set_"; 
		String[] helpstr = {"1e0l","1e6k","1o8w","1odd","1onl","1pzc","1r9h","1sha","1ugm"};
		for(int i = 0; i < helpstr.length; i++){
			NbhStringRanker r = new NbhStringRanker();
			NhbString nbh = r.new NhbString (dira + helpstr[i] + "/" + helpstr[i] + dirb);
			r.setNbhRanker(nbh);
			r.runQueries();
			r.writeToFile(dira + helpstr[i] + "/" + helpstr[i] + dirb + "nbh_string/", helpstr[i] + "run");
			r.close();
			NbhStringRanker s = new NbhStringRanker ();
			NhbString nbh2 = s.new NhbString (dira + helpstr[i] + dirc + helpstr[i] + "/");
			s.setNbhRanker(nbh2);
			s.runQueries();
			s.writeToFile(dira + helpstr[i] + dirc + helpstr[i] + "/",helpstr[i] + "run");
			s.close();
		}
	}
	
	/**
	 * inner class: this should be used as an auxiliary class, in order to deal with plenty of contact map files.
	 * This class can list all contact map files, converts them to a <code>{@link Individuals}</code> instance (by
	 * calling the single parameter constructor <code>{@link Individuals#Individuals(String)}</code>), extracts
	 * the contact map table and creates String instances, which represent the neighborhood Strings. In order to
	 * keep output at a low level, one can simply transfer all fields of this class to the outer class, by
	 * calling the method <code>{@link NbhStringRanker#setNbhRanker(NhbString)}</code>.
	 * <p>
	 * It is important to notice,
	 * that any use of this class to convert a set of contact map files at the same times, causes an IllegalArgumentException,
	 * if the denoted directory contains at least one file, with a different pdb code.
	 * </p>
	 * @author gmueller
	 *
	 */
	class NhbString {
		
		/**
		 * a HashMap of a HashMap, that contains all positions of the primary sequence as keys and maps them onto their contact partners (inner HashMap).
		 * It is possible to deal with several contact map files at once, that's why the outer HashMap is just a list of all contacts of different
		 * contact map files.
		 */
		private HashMap<Integer,HashMap<Integer,HashSet<Integer>>> index_map_sparse;
		
		/**
		 * a HashMap, that maps all amino acids (key) to a Set of amino acids (their contact partners)
		 */
		private HashMap<String,HashSet<String>> contact_to_nbhstring;
		
		/**
		 * a helper: maps all amino acids onto their contact partners
		 */
		private HashMap<Integer,Integer> index_counter;
		
		/**
		 * a helper: maps the position onto the single letter amino acid code
		 */
		private HashMap<Integer,String> sequence;
		
		/**
		 * the actual neighborhood String table, contains all contact partners with their neighborhood Strings
		 */
		private String content;
		
		/**
		 * helper: if several contact map files are converted, this field insures that no contact map file
		 * of a protein with an other pdb code is used at the same time. Otherwise, an IllegalArgumentException
		 * will be thrown.
		 */
		private String pdb_code;
		
		/**
		 * the chain code of the protein
		 */
		private String chain_code;
		
		/**
		 * a String denoting the directory containing the contact map files
		 */
		String path;
		
		/**
		 * default neighborhood String separator
		 */
		private static final String separator = "%x";
		
		/*---------------------------------------constructors-------------------------------------------------------*/
		
		/**
		 * one-parameter constructor: initializes an instance of this class, by extracting the contact map tables, pdb codes,
		 * chain codes etc. from a contact map file, in order to convert them to a neighborhood String.
		 * @param dir a String instance denoting a directory
		 */
		public NhbString (String dir) throws IOException, SQLException, PdbCodeNotFoundException, PdbLoadError, IllegalArgumentException {
			setNeighbourhoodString(dir);
		}
		
		
		/*----------------------------------------setters------------------------------------------------------------*/
		
		/**
		 * initial setter: initialized all instances of this class. It checks whether the denoted directory exists and issues an
		 * IllegalArgumentException if does not exist. 
		 * @param dir a String instance denoting a directory
		 * @throws IOException
		 * @throws SQLException
		 * @throws PdbCodeNotFoundException
		 * @throws PdbLoadError
		 * @throws IllegalArgumentException if the denoted director does not exist
		 * @throws
		 *  
		 */
		public void setNeighbourhoodString (String dir) throws IOException, SQLException, PdbCodeNotFoundException, PdbLoadError, IllegalArgumentException {
			File is_f = new File(dir);
			if(is_f.exists()){
				path = new String(dir);
				setFileSys(dir);
				setContactToNbhString();
			}
			else{
				throw new IllegalArgumentException("The path '"+dir+"' does not exist.");
			}
		}
		
		/*---------------------------------------auxiliaries---------------------------------------------------------*/
		
		/**
		 * auxiliary setter: initializes the field <code>{@link #sequence}</code> by taking the sequence String of an
		 * Individuals instance and adds it to the HashMap, where the key is a Integer (index i + 1) of the character array 
		 * and the entries are single character Strings (i.e. the corresponding single code amino acid at position i). 
		 */
		public void setSequence(String seq){
			if(seq != null && sequence == null){
				sequence = new HashMap<Integer,String> (); 
				for(int i = 0; i <seq.length(); i++){
					Integer index = new Integer (i + 1);
					String substr = seq.substring(i, i + 1);
					sequence.put(index, substr);
				}
			}
			else{
				if(seq == null){
					throw new NullPointerException ("The parameter 'seq' must always be initialized before calling the method 'seqSequence(String).");
				}
			}
		}
		
		/**
		 * auxiliary setter: takes the fields <code>{@link #index_map_sparse}</code> and <code>{@link #sequence}</code>
		 * and converts to a String table. The <tt>index_map_sparse</tt> contains all contact partner of a given entry, runs
		 * through the sequence and puts the single amino acid code, representing the contact partner, either to the left or right,
		 * depending on whether the primary sequence index (i.e. the position) is less or greater than the position index of the current
		 * amino acid. Each single letter code is separated by the wildcard '%' and the current amino acid is only represented by a default
		 * 'x', indicating no specific amino acid was chosen.
		 */
		public void setContent (){
			if(index_map_sparse != null && sequence != null){
				HashMap<Integer,String> seq_map = getSequence();
				HashMap<Pair<Integer>,HashSet<Integer>> ind_map1 = convertToPairHashMap();
				Set<Pair<Integer>> keyset = ind_map1.keySet();
				int[][] index_ar = SortIntArray.converter(keyset);
				int length = index_ar[0].length;
				if(content == null){
					content = "";
				}
				for(int i = 0; i < length; i++){
					Integer index  = new Integer (index_ar[0][i]);
					Integer hindex = new Integer (index_ar[1][i]);
					Pair<Integer> pair = new Pair<Integer> (index,hindex);
					HashSet<Integer> subset = ind_map1.get(pair);
					
					Iterator<Integer> it = subset.iterator();
					String neighbours_left1 = getPDBCode() + "\t" + getChainCode() + "\t" + index.toString() + "\t" + seq_map.get(index) + "\t";
					String neighbour_right1 = "";
					while(it.hasNext()){
						
					int index2 = it.next();					
					
					
						if(index2 < index.intValue()){
							neighbours_left1 += "%" + seq_map.get(new Integer (index2));
						}
						else{
							neighbour_right1 += "%" + seq_map.get(new Integer (index2));
						}
					}
					neighbour_right1 += "%\n";
					content += neighbours_left1 + separator + neighbour_right1;
				}
			}
			else{
				throw new NullPointerException ("Both fields 'index_map' and 'sequence' must be initialized before calling the method 'setContent()'!");
			}
		}
		
		/**
		 * auxiliary setter: a directory, denoted by the parameter <tt>dir</tt> is checked, whether it
		 * contains any file, so that the method <code>{@link Individuals#containsReadableFiles(File)}</code>
		 * returns true. Thereafter, each matching file is read via the <code>{@link Individuals#Individuals(String)}</code>
		 * constructor, taking the pdb code and chain code of each file and compares them for consistency. If either of the to
		 * fields do not match in an individuals run, an IllegalArgumentException is thrown. The locally initialized <tt>Individuals</tt>
		 * instance is used to get the index map, which contains all position indexes of a given contact map and maps them onto their contact partners.
		 * @param dir
		 * @throws IOException
		 * @throws SQLException
		 * @throws PdbCodeNotFoundException
		 * @throws PdbLoadError
		 * @throws IllegalArgumentException
		 */
		public void setFileSys (String dir) throws IOException, SQLException, PdbCodeNotFoundException, PdbLoadError, IllegalArgumentException {
			File file = new File (dir);
			if(file.exists() && file.isDirectory()){
				String[] file_f = Individuals.file_extension;
				File[] file_list = null;
				int length = 0;
				for(int i = 0; i < file_f.length; i++){
					file_list = file.listFiles(new RegexFileFilter (".*." + file_f[i]));
					length = file_list.length;
					if(length > 0){
						break;
					}
				}
				for(int i = 0; i < length; i++){
					if(Individuals.isReadableFileFormat(file_list[i])){
						Individuals in = new Individuals (file_list[i].getAbsolutePath());
						if(chain_code == null){
							chain_code = new String (in.getChainCode());
						}
						else{
							if(!chain_code.matches(in.getChainCode())){
								throw new IllegalArgumentException ("The protein chain codes of the files listed in the denoted directory do not match!");
							}
						}
						if(pdb_code == null){
							pdb_code = new String (in.getName());
						}
						else{
							if(!pdb_code.matches(in.getName()))
							throw new IllegalArgumentException ("The pdb codes of the files listed in the denoted directory do not match!");
						}
						extractContactMap(in.getHashSet());
						setSequence(in.getSequence());
					}
				}
				setContent();
			}
		}
		
		/**
		 * auxiliary method: sets the fields <code>{@link #index_map_sparse}</code> and <code>{@link #index_counter}</code> by getting
		 * all contact pairs <code>(i,j)</code> from the parameter 'contactset' and stores them in both fields. In <code>{@link #index_map_sparse}</code> all
		 * indices <code>i,j</code> and their nodes are stored while in <code>{@link #index_counter}</code> each index and its frequencies are stored.
		 * @param contactset
		 */
		public void extractContactMap (HashSet<Pair<Integer>> contactset){
			HashMap<Integer,HashSet<Integer>> inner_map = new HashMap<Integer,HashSet<Integer>> ();
			Integer initial = null;
			if(index_map_sparse == null && index_counter == null){
				index_map_sparse = new HashMap<Integer,HashMap<Integer,HashSet<Integer>>> ();
				//HashMap containing all indices contained in the 'contactset' parameter
			
				index_counter = new HashMap<Integer,Integer>();
				//HashMap counting the frequencies of each index in the 'contactset' parameter
				
				initial = new Integer (1);
				
			}
			else{
				Set<Integer> keys = index_map_sparse.keySet();
				Integer[] ar = keys.toArray(new Integer[1]);
				Arrays.sort(ar);
				initial = new Integer (ar[ar.length - 1].intValue() + 1);
			}
						
			Iterator<Pair<Integer>> it = contactset.iterator();
			while(it.hasNext()){
				//loop over all entries in the HashSet 'contactset'
				
				Pair<Integer> pair = it.next();
				Integer f_val = pair.getFirst(), s_val = pair.getSecond();
				HashSet<Integer> indeces = new HashSet<Integer> ();
				//a HashSet counting the frequencies of each index
				
				if(inner_map.containsKey(f_val)){
					//check whether the first value is already present in the HashMap
					
					indeces = new HashSet<Integer> (inner_map.get(f_val));
					indeces.add(s_val);
					inner_map.put(f_val, indeces);
					int counter1 = index_counter.get(f_val).intValue() + 1;
					index_counter.put(f_val, new Integer(counter1));
				}
				else{
					//if the first value is not present yet
					indeces.add(s_val);
					inner_map.put(f_val, indeces);
					index_counter.put(f_val, new Integer(1));
				}
				indeces = new HashSet<Integer> ();
				if(inner_map.containsKey(s_val)){
					//check whether the second value is already present in the HashMap
					
					indeces = new HashSet<Integer> (inner_map.get(s_val));
					indeces.add(f_val);
					inner_map.put(s_val,indeces);
					int counter1 = index_counter.get(s_val).intValue() + 1;
					index_counter.put(s_val, new Integer(counter1));
				}
				else{
					//if the second value is not present yet
					
					indeces.add(f_val);
					inner_map.put(s_val, indeces);
					index_counter.put(s_val, new Integer(1));
				}
				index_map_sparse.put(initial, inner_map);
			}
		}
		
		/**
		 * 
		 */
		public void setContactToNbhString (){
			if(content != null){
				String[] str_array = content.split("\n");
				int length = str_array.length;
				contact_to_nbhstring = new HashMap<String,HashSet<String>> (2 * length);
				for(int i = 0; i < length; i++){
					String[] substr = str_array[i].split("\t");
					String f_val = substr[3] + substr[2];
					String s_val = substr[4];
					if(contact_to_nbhstring.containsKey(f_val)){
						HashSet<String> subset = getSubSet(f_val);
						subset.add(s_val);
						contact_to_nbhstring.put(f_val, subset);
					}
					else{
						HashSet<String> subset = new HashSet<String> ();
						subset.add(s_val);
						contact_to_nbhstring.put(f_val, subset);
					}
				}
			}
		}
		
		public HashMap<Integer,HashMap<Integer,HashSet<Integer>>> getIndexMap (){
			return new HashMap<Integer,HashMap<Integer,HashSet<Integer>>>(index_map_sparse);
		}
		
		public String getChainCode(){
			return new String (chain_code);
		}
		public String getPDBCode (){
			return new String (pdb_code);
		}
		
		public HashMap<Integer,String> getSequence (){
			return new HashMap<Integer,String>(sequence);
		}
		
		public HashSet<String> getSubSet (String key){
			return new HashSet<String> (contact_to_nbhstring.get(key));
		}
		
		public HashMap<String,HashSet<String>> getContToNbh (){
			return new HashMap<String,HashSet<String>> (contact_to_nbhstring);
		}
		
		public String toString(){
			return new String (content);
		}
		
		public Individuals[] getIndividualsFirstAndLast(String dir) throws IOException, SQLException, PdbCodeNotFoundException, PdbLoadError{
			Individuals[] first_n_last = new Individuals[2];
			File file = new File(dir);
			if(Individuals.containsReadableFiles(file)){
				boolean is_not_empty = false;
				int i = 0;
				File[] list = new File[0];
				while(!is_not_empty){
					if(i >= Individuals.file_extension.length){
						break;
					}
					list = file.listFiles(new RegexFileFilter(".*."+Individuals.file_extension[i]));
					if(list.length > 0){
						is_not_empty = true;
					}
					i++;
				}
				if(list.length > 0){
					Arrays.sort(list);
					first_n_last[0] = new Individuals(list[0].getAbsolutePath());
					first_n_last[1] = new Individuals(list[list.length-1].getAbsolutePath());
				}
				else{
					throw new IllegalArgumentException("The denoted path does not contain any readable files...");
				}
				return first_n_last;
			}
			else{
				throw new IllegalArgumentException("The denoted path does not contain any readable files...");
			}
		}
		
		public int[] convertHashSetToIntArray (HashSet<Integer> set){
			if(set != null){
				int[] array = new int[set.size()];
				int counter = 0;
				Iterator<Integer> it = set.iterator();
				while(it.hasNext()){
					array[counter] = it.next().intValue();
					counter++;
				}
				Arrays.sort(array);
				return array;
			}
			else{
				throw new NullPointerException("The parameter 'set' must never be null.");
			}
		}
		
		public HashMap<Pair<Integer>,HashSet<Integer>> convertToPairHashMap (){
			HashMap<Integer,HashMap<Integer,HashSet<Integer>>> map = getIndexMap();
			HashMap<Pair<Integer>,HashSet<Integer>> fused_map = new HashMap<Pair<Integer>,HashSet<Integer>> ();
			Set<Integer> key1 = map.keySet();
			Iterator<Integer> it1 = key1.iterator();
			while(it1.hasNext()){
				Integer index1 = it1.next();
				HashMap<Integer,HashSet<Integer>> submap = map.get(index1);
				Set<Integer> key2 = submap.keySet();
				Iterator<Integer> it2 = key2.iterator();
				while(it2.hasNext()){
					Integer index2 = it2.next();
					HashSet<Integer> set = submap.get(index2);
					Pair<Integer> pair = new Pair<Integer> (index2,index1);
					fused_map.put(pair, set);
				}
			}
			return fused_map;
		}
	}
}
